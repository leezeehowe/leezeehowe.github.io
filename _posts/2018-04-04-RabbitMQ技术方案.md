---
layout: post
title: "初步认识RabbitMQ"
subtitle: '消息队列'
author: "lee"
header-style: text
tags:
	- 消息队列
	- RabbitMQ
---

# !初步认识RabbitMQ

[TOC]

## 一、简介

RabbitMQ是一个使用Erlang语言开发的C/S架构的消息代理或称消息队列，是AMQP协议(Advance Message Queue Protocal)的开源实现。

> 什么叫消息队列？
>
> 消息是指在应用程序（进程）间传递的数据，可以是简单的字符串或者更复杂的对象。消息队列是一种进程间的通信方式，发送方将消息发送到消息队列交由其代理，当某一个进程需要该消息，就从消息队列取，完成了发送方与接收方的解耦。

##  二、基本概念

### 1. 架构模型

![](<http://lee-image.test.upcdn.net/md/5015984-367dd717d89ae5db.webp>)

Publisher即消息发送方另称生产者，Consumer即消息接收方另称消费者，一般都是一个应用程序进程。中间的Broker即一台跑着RabbitMQ server进程的实体服务器。Connecion是一个TCP连接。生产者通过Connection将消息推送到Broker由其代理，消费者通过Connection向Broker订阅消息。

### 2. 概念

#### 2.1 Publisher：消息推送方

消息的生产者。通过交换器向Virtual Host推送消息。

#### 2.2 Consumer：消息接收方

消息的消费者。通过订阅队列从Virtual Host取得消息。

#### 2.3 Exchange：交换器

交换器，Virtual Host内部的组件。根据不同的交换器类型以及路由键把生产者推送的消息转移到队列中。

#### 2.5 Routing-key：路由键

路由键，即一个标识符或者令牌。消息、交换器和队列都会使用到。

#### 2.4 Binding：绑定

路由绑定。交换器与队列间的组件。交换器与队列原本就是互相独立，彼此不相连。当用户给予交换器e和队列q一个路由键（令牌）时，即相当于在e和q之间建了一条洲际大桥，消息可以在这条洲际大桥上进行输送。

#### 2.5 Queue：队列

队列，消息的容器。

#### 2.6 Virtual Host：虚拟主机

RabbitMQ消息队列服务器进程，即一个RabbitMQ软件进程。拥有一批交换器和队列。

#### 2.7 Broker：一台实体主机

物理服务器，即一台运行着一个或多个Virtual Host的实体电脑。

#### 2.8 Message：消息

消息，由消息头和消息体组成。消息体即生产者实际希望发送出去的数据，消息头由一系列可选的RabbitMQ定义的属性组成，包括routing-key路由键、priority优先级等待，即用于告诉Virtual Host如何代理该消息。

#### 2.9 Connection 连接

即一条TCP连接，具有多信道特征。

#### 2.10 Channel 信道

信道，一条独立的双向数据流通道。信道是建立在真实的TCP连接内地一条虚拟连接，生产者和消费者只能通过信道与Virtual Host进行交互。

>为什么RabbitMQ不直接使用Connection呢？
>
>对于OS来说，建立和关闭TCP连接是有代价的，频繁的建立关闭TCP连接对于系统的性能有很大的 影响，而且TCP的连接数也有限制，这也限制了系统处理 高并发的能力。但是，在TCP连接中建立 Channel是没有上述代价的。对于Producer或者Consumer来说，可以并发的使用多个 Channel进行 Publish或者Receive。

## 三、关键技术点

### 1. 路由机制

#### 1.1 路由表

```javascript
// Virtual Host 维护的路由表数据结构
let binding_table = {
    // 交换器1
    exchange_1: [
        // 绑定项
        {
            // 绑定的队列的标识符
            queue_name: "队列1",
            // 绑定键，与消息头的路由键进行匹配
            binding_key: "success"
        },
        {
            queue_name: "队列2",
            binding_key: "error"
        },
        // ...
    ],
    // 交换器2
    exchange_2: [],
    exchange_3: [],
    // ...
}
```

#### 1. 2 交换器类型

##### 1.1.1 direct--- 全字匹配类型

![1561025697607](<http://lee-image.test.upcdn.net/md/direct.png>)

direct类型的交换器，只有当消息头的 路由键值 与 绑定键值 完全相等时，交换器才会把消息发送到与该绑定键对应的队列上。 

##### 1.1.2 fanout-- 广播类型

![](<http://lee-image.test.upcdn.net/md/fanout.png>)

fanout类型的交换器，会忽略消息头的路由键，直接按照路由表中的绑定项把该消息发送到所有与其绑定的队列，相当于局域网的广播模式。

##### 1.1.3 topic----模式匹配类型

![](<http://lee-image.test.upcdn.net/md/topic.png>)

topic类型的交换器，相当于正则匹配，`*`表示匹配一个关键词，`#`表示匹配0或多个关键词，例如`log.#`能匹配`log.success.user`,而`log.*`不能匹配`log.success.user`。topic类型的交换器相当于把消息归档为多个主题。

### 2. 消息队列

当rabbit无法直接将消息传递到消费者时，需要将消息拖放到队列中，此时Rabbit有一套状态转换机制管理队列中的消息。

#### 2.1 消息的四种状态

> 消息的内容：内容
> 消息的索引：消息在队列中的位置。

| 状态名 | 内容的位置 | 索引的位置   | 特征                                |
| ------ | ---------- | ------------ | ----------------------------------- |
| alpha  | 内存       | 内存         | 最消耗内存，很少消耗CPU             |
| beta   | 硬盘       | 内存         | 需要进行一次IO操作读取内容          |
| gamma  | 硬盘       | 硬盘 和 内存 | 需要进行一次IO操作读取内容          |
| delta  | 硬盘       | 硬盘         | 基本不消耗内存，但是消耗CPU和磁盘IO |

注意：对于持久化消息，内容和索引都必须先保存在硬盘中然后才会处于上述四种状态的一种。

#### 2.2 队列中的五个内置队列

队列中其实存在五个内置队列，分别用于存储处于不同状态的消息。

```erlang
%% vqstate是一个描述当前队列的信息的数据结构
-record(vqstate,
       {
        q1,
        q2, 
        delta,
        q3,
        q4,
        %% ... 省略
       })
```

| 内置队列名 | 作用                            |
| ---------- | ------------------------------- |
| q1         | 保存队列中alpha状态的消息       |
| q2         | 保存队列中beta和gamma状态的消息 |
| delta      | 保存队列中delta状态的消息       |
| q3         | 保存队列中beta和gamma状态的消息 |
| q4         | 保存alpha状态的消息             |

#### 2.3 消息状态转换机制

```erlang
-record(vqstate, 
        {
         %% ... 省略
         out_counter, %% 进队列的消息数量
         in_counter, %% 出队列的消息数量
         ack_out_counter, %% 退出队列等待ack的消息数量
         ack_in_counter, %% 进入队列等待ack的消息数量
         target_ram_count, %% 当前队列允许保存在内存中的消息的最大数量
         rates,
         %% ... 省略
        }).

-record(rates, {
				in,					%% 消息进入队列的速率
				out,				%% 消息出队列的速率
				ack_in,				%% 消息ack进入队列的速率
				ack_out,			%% 消息ack出队列的速率
				timestamp
			   }).
```

rabbit存在一个  memory_monitor 进程 根据当前队列状态的rates属性计算消息进出速率然后更新target_ram_count(允许保存在内存中的消息数量)，当队列保存在内存中的消息数量大于更新后的target_ram_count，就会立即触发 reduce_memory_use() 操作。

此时，就会引起消息的状态转换，转换主要有两种： 

- alpha -> beta

  将消息的内容写到磁盘（如果是持久化消息，在 这一步转换后，消息将会处于gamma状态）

- beta -> delta

  会更进一步减少内存消耗，将消息索引也 写到磁盘。 

#### 2.4 消息流动机制

##### 2.4.1 消息进队列

当消息进入队列时，一般情况下消息会以q1->q2->delta->q3->q4的顺序进行状态变换：消息进入队列时，处于alpha状态并保存 在内存中（q1或q4），然后某个时刻发现内存不足，被转换到beta状态（q2，q3）（这时候其实有两个转换 q1->q2，q4->q3），如果还是内存不足，被转换到delta状态（delta）（q2->delta，q3->delta）；

![](http://lee-image.test.upcdn.net/md/消息状态转换机制.png)

##### 2.4.2 消息出队列

当从队列中消费消息时，会先从处于alpha状态的内存队列（q4）中获取消息，如果q4为空，则从beta状态的队列（q3）中获取消息，如果q3也为空，则会从delta状态的消息队列中读取消息，并将之转移到q3。 

```erlang
%% 从队列中获取消息)
queue_out(State = #vqstate { q4 = Q4 }) ->
    %% 首先尝试从Q4队列取消息
	case ?QUEUE:out(Q4) of
        %% Q4队列为空，尝试从Q3队列取消息
		{empty, _Q4} ->
			case fetch_from_q3(State) of
                %%% Q3队列也为空，直接返回空
				{empty, _State1} = Result -> Result;
				{loaded, {MsgStatus, State1}} -> {{value, 					MsgStatus}, State1}
			end;
        %% Q4队列不为空，取出消息，更新当前队列的vqstate记录
		{{value, MsgStatus}, Q4a} ->
			{{value, MsgStatus}, State #vqstate { q4 = Q4a 				}}
	end.
```

```erlang
%% 从队列Q3中读取消息
fetch_from_q3
(State = #vqstate { q1    = Q1,
					q2    = Q2,
					delta = #delta { count = 									DeltaCount },
				    q3    = Q3,
					q4    = Q4 
    				}
) ->
    %% 尝试从Q3队列取消息
	case ?QUEUE:out(Q3) of
        %% Q3队列为空，直接返回空
		{empty, _Q3} ->
			{empty, State};
        %% Q3队列不为空，取出消息
		{{value, MsgStatus}, Q3a} ->
			State1 = State #vqstate { q3 = Q3a },
			State2 = case 
                     %% 判断 Q3 和 delta队列是否为空
                     {?QUEUE:is_empty(Q3a), 
                      0 == DeltaCount
                      }  of
                         %% Q3 和 delta都为空
						 {true, true} ->
                             %% 断言 Q2 和 Q4都为空
							 true = ?QUEUE:is_empty(Q2), 
							 true = ?QUEUE:is_empty(Q4), 
							 %% 把Q1的消息放到Q4,从新初始化一个Q1							 队列
                             State1 #vqstate { q1 = ?QUEUE:new(), q4 = Q1 };
                         %% Q3为空，delta队列不为空
						 {true, false} ->
                             %% 尝试把delta队列的消息放到Q3队列
							 maybe_deltas_to_betas(State1);
						 %% Q3不为空，直接返回
                         {false, _} ->
							 State1
					 end,
			{loaded, {MsgStatus, State2}}
	end.
```

## 四、 应用场景

### 1. RPC远程调用

RPC（Remote Procedure Call）—[远程过程调用](https://baike.baidu.com/item/远程过程调用/7854346)，它是一种通过[网络](https://baike.baidu.com/item/网络/143243)从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。[RPC协议](https://baike.baidu.com/item/RPC协议)假定某些[传输协议](https://baike.baidu.com/item/传输协议/8048821)的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI[网络通信](https://baike.baidu.com/item/网络通信/9636548)模型中，RPC跨越了[传输层](https://baike.baidu.com/item/传输层/4329536)和[应用层](https://baike.baidu.com/item/应用层/4329788)。RPC使得开发包括网络[分布式](https://baike.baidu.com/item/分布式)多程序在内的应用程序更加容易。

RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。

#### 1.1 关键流程梳理

用RabbitMQ实现RPC的基本步骤如下：

1. 当RPC客户端启动时，会创建一个匿名的私有的回调队列。
2. 对于RPC请求，客户端发送带有两个属性的消息：repl_to 指定为回调队列的标识符，correlation_id 指定为本次RPC请求的标识符。
3. 客户端发送RPC请求到rpc_queue队列。
4. RPC服务端侦测到rpc_queue队列中出现消息（RPC请求）时，执行作业然后把作业结果推送到消息头的repl_to字段指定的回调队列中。
5. 客户端等待回调队列上的数据。当侦测到消息时，检查correlation_id字段的值，如果它与请求中的值匹配，则将响应返回给应用程序。

![](http://lee-image.test.upcdn.net/md/RPC实现.png)

## 五、Docker 部署RabbitMQ

首先上dockerhub搜索rabbitMQ

![](http://lee-image.test.upcdn.net/md/dockerhub%E6%90%9C%E7%B4%A2rabbitMQ.png)

我们使用3.8版本。点击可以查看dockerfile，我们通过dockerfile构建镜像。

3.8-rc是不带web管理界面的，3.8-rc-management是带web管理界面的。

### 1. rabbitMQ的dockerfile

#### 1.1 版本3.8-rc的dockerfile

```dockerfile
# ubnutu:18.04为上层镜像
FROM ubuntu:18.04
# rabbitMQ的data目录路径，估计是持久化文件的存放路径
ENV RABBITMQ_DATA_DIR=/var/lib/rabbitmq
# rabbitMQ的安装目录
ENV RABBITMQ_HOME=/opt/rabbitmq
# 指定了该镜像暴露该data路径可以被外部主机挂载，构建镜像时可以通过-v 把该路径挂载到外部主机的指定目录
VOLUME $RABBITMQ_DATA_DIR
# 暴露了以下端口
EXPOSE 4369 5671 5672 25672
# 开启rabbitMQ服务
CMD ["rabbitmq-server"]
```

#### 1.2 版本3.8-rc-management的dockerfile

```dockerfile
# 可以看到，该镜像的上层是3.8-rc，所以我们可以直接使用这个dockerfile
FROM rabbitmq:3.8-rc
# 开启rabbitMQ的web管理界面插件
RUN rabbitmq-plugins enable --offline rabbitmq_management

RUN set -eux; \
	erl -noinput -eval ' \
		{ ok, AdminBin } = zip:foldl(fun(FileInArchive, GetInfo, GetBin, Acc) -> \
			case Acc of \
				"" -> \
					case lists:suffix("/rabbitmqadmin", FileInArchive) of \
						true -> GetBin(); \
						false -> Acc \
					end; \
				_ -> Acc \
			end \
		end, "", init:get_plain_arguments()), \
		io:format("~s", [ AdminBin ]), \
		init:stop(). \
	' -- /plugins/rabbitmq_management-*.ez > /usr/local/bin/rabbitmqadmin; \
	[ -s /usr/local/bin/rabbitmqadmin ]; \
	chmod +x /usr/local/bin/rabbitmqadmin; \
	apt-get update; apt-get install -y --no-install-recommends python; rm -rf /var/lib/apt/lists/*; \
	rabbitmqadmin --version
# 暴露了以下端口，15672是web管理界面的端口
EXPOSE 15671 15672
```

### 2. 通过dockerfile构建镜像

在/usr/local目录下创建一个docker目录专门用来存放docker安装的容器

创建一个rabbitMQ-3.8-rc目录

```bash
root@iZwz94evk2isosdfz1k398Z:/# cd /usr/local
oot@iZwz94evk2isosdfz1k398Z:/usr/local# mkdir docker/rabbitmq-3.8-rc
```

进入然后编写dockerfile文件

```
root@iZwz94evk2isosdfz1k398Z:/usr/local# cd docker/rabbitmq-3.8-rc && vim Dockerfile
```

把刚刚提到的3.8-rc-management的dockerfile文件照样copy上去保存就可以了。

使用dockere build 命令构建镜像，-t 是指定镜像名，-q 是使用安静模式即构建过程不输出内容只在构建完成后输出镜像id， . 是使用当前目录下的Dockerfile文件构建镜像。

```
root@iZwz94evk2isosdfz1k398Z:/usr/local/docker/rabbitmq-3.8-rc# docker build -t rabbitmq-3.8-rc-management -q .
```

构建过程中会自动下载所需的镜像，构建完成后，输出了镜像id即代表成功。

```basic
sha256:a445e025edb687430f9de5aace3e68f7664459aa556a4648cf33f3955ff6bd8b
```

使用docker images 命令可以看到多了一个rabbitmq-3.8-rc-management的镜像。

### 3. 开启rabbitMQ容器

使用docker run 命令通过镜像运行一个容器。

```
-d : 后台运行容器，并返回容器id

--hostname: 为rabbitMQ指定一个主机名否则会获得随机主机名

--name: 为容器指定一个名字

-v: 挂载目录，例如可以把 $RABBITMQ_DATA_DIR 挂载到宿主机的指定目录下。

-p: 端口映射，格式 宿主机端口:容器端口。

设置默认用户和密码：
	默认的用户名和密码是guest，
	使用 
	-e RABBITMQ_DEFAULT_USER=用户名 
	-e RABBITMQ_DEFAULT_PASS=密码
    可以修改。
  
```

接下来运行容器

```
root@iZwz94evk2isosdfz1k398Z:/usr/local/docker/rabbitmq-3.8-rc# docker run -d --hostname rabbit --name rabbit -e RABBITMQ_DEFAULT_USER=lee -e RABBITtname rabbit --name rabbit -e RABBITMQ_DEFAULT_USER=[用户名] -e RABBITMQ_DEFAULT_PASS=[密码] -v /usr/local/docker/rabbitmq-3.8-rc/rabbit_data:/var/lib/rabbitmq -p 4369:4369 -p 5671:5671 -p 5672:5672 -p 25672:25672 -p 15671:15671 -p 15672:15672 a445e025edb6
```

成功输出容器id并且/usr/local/docker/rabbitmq-3.8-rc目录下自动生成了一个rabbit_data目录。

```
bd5c197f8eeefbf6a8459b787a0c3db776362dca0a94787e3e2e754ece598d90
root@iZwz94evk2isosdfz1k398Z:/usr/local/docker/rabbitmq-3.8-rc/rabbit_data# ls
config  mnesia  schema
```

使用docker ps 命令查看容器运行状态。

![](http://lee-image.test.upcdn.net/md/rabbitmMQ容器运行状态.png)

使用自己修改过的默认用户和密码即可登录web端管理界面，默认端口是15672。

![](http://lee-image.test.upcdn.net/md/web端管理.png)


